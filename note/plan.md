# 函数式编程
 
May 29, 2016 12:41 PM

[TOC]

我一次又一次的告诉自己，一切都要从基础做起，不要急功近利]

* ####概要
	1. 函数是python内建支持的一种封装。
		我们通过函数调用，把复杂的任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。
    2. 函数式编程就是一种抽象程度很高的编程范式。
    	它有一个很大的特点，就是允许把函数本身作为参数传入另一个函数，还允许返回一个函数！
    3. 函数式编程的五个特点

    	- 函数是"第一等公民"

    	所谓"第一等公民"（first class），指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。函数本身也可以赋值给变量
        举例来说，下面代码中的print变量就是一个函数，可以作为另一个函数的参数。
					var print = function(i){ console.log(i);};
					[1,2,3].forEach(print);

		- 只用"表达式"，不用"语句"

		"表达式"（expression）是一个单纯的运算过程，总是有返回值；"语句"（statement）是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。
        - 没有"副作用"

        所谓"副作用"（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。
        函数式编程强调没有"副作用"，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。

        - 不修改状态

		函数式编程只是返回新的值，不修改系统变量。因此，不修改变量，也是它的一个重要特点

        - 引用透明
        
        引用透明（Referential transparency），指的是函数的运行不依赖于外部变量或"状态"，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。
* ####高阶函数
	把函数作为参数传入，这样的函数称为高阶函数，函数式编程就是指这种高度抽象的编程范式。
    既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数.
    #####1.map/reduce
    map()函数接收两个参数，一个是函数，一个是Iterable，`map`将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。
   			>> def f(x):
		        		return x * x
				>>>r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
				>>> list(r)
				[1, 4, 9, 16, 25, 36, 49, 64, 81
    再看`reduce`的用法。`reduce`把一个函数作用在一个序列 `[x1, x2, x3, ...]`上，这个函数必须接收两个参数，`reduce`把结果继续和序列的下一个元素做累积计算，其效果就是：
    		reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
  
  下面这个方法，整合了map和reduce，可以实现把由数字组成的字符串
 
				from functools import reduce
				def str2int(s):
 					def fn(x, y):
        				return x * 10 + y
    				def char2num(s):
        				return {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}[s]
                   return reduce(fn, map(char2num, s))

   #####2.filter
   #####3.sorted
   * 对list直接进行排序
   		>>> sorted([36, 5, -12, 9, -21])
		    	[-21, -12, 5, 9, 36]
   * sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序：
   		>>> sorted([36, 5, -12, 9, -21], key=abs)
			[5, 9, -12, -21, 36]
            
   *  默认情况下，对字符串排序，是按照ASCII的大小比较的，由于'Z' < 'a'，结果，大写字母Z会排在小写字母a的前面
   *  我们给sorted传入key函数，即可实现忽略大小写的排序：

			>>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower)
				['about', 'bob', 'Credit', 'Zoo']   
                
  * 要进行反向排序，不必改动key函数，可以传入第三个参数reverse=True：
  			>>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
				['Zoo', 'Credit', 'bob', 'about']   
  * 
        
* ####返回函数
 
* ####匿名函数
	当我们在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便在Python中，对匿名函数提供了有限支持。还是以map()函数为例，计算f(x)=x2时，除了定义一个f(x)的函数外，还可以直接传入匿名函数：

			>>> list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
				[1, 4, 9, 16, 25, 36, 49, 64, 81]
 关键字lambda表示匿名函数，冒号前面的x表示函数参数。
 匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：

		>>> f = lambda x: x * x
		>>> f
		<function <lambda> at 0x101c6ef28>
		>>> f(5)
		25
同样，也可以把匿名函数作为返回值返回，比如：

		def build(x, y):
    		return lambda: x * x + y * y        
 定义的lambda函数`lambda x, y: x * x + y * y`其实就相当于：
 		def f(x, y):
  			 return x * x + y * y
   
	那么我们要调用的就需要：
		f=build(x, y):
    	f(x,y)
那么这里需要注意了，如果是build(x,y)这种形式，那么`x,y`肯定也是适用于lambda函数的，而如果是`build（）`这样最外层函数没有参数的，`lamda`函数就需要赋值了，通过`f(x,y)`来进行赋值。
* ####装饰器
	- [Python装饰器学习（九步入门）](http://www.cnblogs.com/rhcad/archive/2011/12/21/2295507.html)
    - [浅谈python装饰器](http://blog.csdn.net/mdl13412/article/details/22608283)
* ####偏函数
 一种基于微信开发模式的信息编辑方法及系统
 微信开发——微信生态的渗透与价值